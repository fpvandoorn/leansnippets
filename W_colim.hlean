import hit.quotient types.W hit.trunc

open eq quotient Wtype sigma equiv equiv.ops

namespace W_colim

  section
  parameters (A : Type) (B : A → Type) (P : (W a, B a) → Type)
             (g : Π⦃a : A⦄ {b : B a} {f : B a → W a, B a}, P (f b) → P (sup a f))
  variables  {a : A} (b : B a) {f : B a → W a, B a} {w : W a, B a} (p : P w) (q : Πb, P (f b))

  inductive W_rel : sigma P → sigma P → Type :=
  | Rmk : Π{a : A} {b : B a} (f : B a → W a, B a) (q : Πb, P (f b)),
          W_rel ⟨f b, q b⟩ ⟨sup a f, g (q b)⟩

  definition W_colim : Type := quotient W_rel

  parameters {A B}
  definition inclusion : W_colim :=
  class_of W_rel ⟨w, p⟩

  abbreviation wι := @inclusion

  parameters {P g}
  definition glue : wι (q b) = wι (g (q b)) :=
  eq_of_rel W_rel (W_rel.Rmk f q)

  protected definition rec {Q : W_colim → Type} (Qincl : Π⦃w : W a, B a⦄ (p : P w), Q (wι p))
    (Qglue : Π⦃a : A⦄ (b : B a) {f : B a → W a, B a} (q : Πb, P (f b)),
      Qincl (q b) =[glue b q] Qincl (g (q b))) (aa : W_colim) : Q aa :=
  begin
    induction aa with v v v' r,
    { induction v with w p, exact Qincl p},
    { induction r, apply Qglue}
  end

  protected definition rec_on [reducible] {Q : W_colim → Type} (aa : W_colim)
    (Qincl : Π⦃w : W a, B a⦄ (p : P w), Q (wι p))
    (Qglue : Π⦃a : A⦄ (b : B a) {f : B a → W a, B a} (q : Πb, P (f b)),
      Qincl (q b) =[glue b q] Qincl (g (q b))) : Q aa :=
  rec Qincl Qglue aa

  theorem rec_glue {Q : W_colim → Type} (Qincl : Π⦃w : W a, B a⦄ (p : P w), Q (wι p))
    (Qglue : Π⦃a : A⦄ (b : B a) {f : B a → W a, B a} (q : Πb, P (f b)),
      Qincl (q b) =[glue b q] Qincl (g (q b)))
    {a : A} (b : B a) {f : B a → W a, B a} (q : Πb, P (f b)) :
    apdo (rec Qincl Qglue) (glue b q) = Qglue b q :=
  !rec_eq_of_rel

  protected definition elim {Q : Type} (Qincl : Π⦃w : W a, B a⦄ (p : P w), Q)
    (Qglue : Π⦃a : A⦄ (b : B a) {f : B a → W a, B a} (q : Πb, P (f b)),
      Qincl (q b) = Qincl (g (q b))) : W_colim → Q :=
  rec Qincl (λa b f q, pathover_of_eq (Qglue b q))

  protected definition elim_on [reducible] {Q : Type} (aa : W_colim)
    (Qincl : Π⦃w : W a, B a⦄ (p : P w), Q)
    (Qglue : Π⦃a : A⦄ (b : B a) {f : B a → W a, B a} (q : Πb, P (f b)),
      Qincl (q b) = Qincl (g (q b))) : Q :=
  elim Qincl Qglue aa

  theorem elim_glue {Q : Type} (Qincl : Π⦃w : W a, B a⦄ (p : P w), Q)
    (Qglue : Π⦃a : A⦄ (b : B a) {f : B a → W a, B a} (q : Πb, P (f b)),
      Qincl (q b) = Qincl (g (q b)))
    {a : A} (b : B a) {f : B a → W a, B a} (q : Πb, P (f b))
      : ap (elim Qincl Qglue) (glue b q) = Qglue b q :=
  begin
    apply eq_of_fn_eq_fn_inv !(pathover_constant (glue b q)),
    rewrite [▸*,-apdo_eq_pathover_of_eq_ap,↑elim,rec_glue],
  end

  protected definition elim_type (Qincl : Π⦃w : W a, B a⦄ (p : P w), Type)
    (Qglue : Π⦃a : A⦄ (b : B a) {f : B a → W a, B a} (q : Πb, P (f b)),
      Qincl (q b) ≃ Qincl (g (q b))) : W_colim → Type :=
  elim Qincl (λa b f q, ua (Qglue b q))

  protected definition elim_type_on [reducible] (aa : W_colim)
    (Qincl : Π⦃w : W a, B a⦄ (p : P w), Type)
    (Qglue : Π⦃a : A⦄ (b : B a) {f : B a → W a, B a} (q : Πb, P (f b)),
      Qincl (q b) ≃ Qincl (g (q b))) : Type :=
  elim_type Qincl Qglue aa

  theorem elim_type_glue (Qincl : Π⦃w : W a, B a⦄ (p : P w), Type)
    (Qglue : Π⦃a : A⦄ (b : B a) {f : B a → W a, B a} (q : Πb, P (f b)),
      Qincl (q b) ≃ Qincl (g (q b)))
    {a : A} (b : B a) {f : B a → W a, B a} (q : Πb, P (f b))
      : transport (elim_type Qincl Qglue) (glue b q) = Qglue b q :=
  by rewrite [tr_eq_cast_ap_fn,↑elim_type,elim_glue];apply cast_ua_fn

  end

end W_colim

attribute W_colim.rec W_colim.elim [unfold 8] [recursor 8]
attribute W_colim.elim_type [unfold 7]
attribute W_colim.rec_on W_colim.elim_on [unfold 6]
attribute W_colim.elim_type_on [unfold 5]

namespace Wtype

  section

  open sigma pi eq is_trunc trunc
  universe variables u v
  variables {A : Type.{u}} {B : A → Type.{v}}

-- THESE lt's are not even the right idea, lt should be generated by "f b < sup f"

  inductive lt : (W a, B a) → (W a, B a) → Type.{max u v} :=
  | mk : Π{a f g}, (Πb, lt (f b) (g b)) → lt (sup a f) (sup a g)

  infix ` < ` := lt

  -- definition lt_eta (v w : W a, B a) (H : v < w) : lt.mk _ = H :=
  -- _

  theorem is_hprop_lt (v w : W a, B a) : is_hprop (v < w) :=
  begin
    apply is_hprop_of_imp_is_contr,
    intro H, induction H with a f g H IH,
    fapply is_contr.mk,
    { exact lt.mk H},
    { intro H, exact sorry},
  end


  definition lt2 (v w : W a, B a) : Type.{max u v} :=
  begin
    revert w, induction v with a f IH, intro w, induction w with a' f' IH2, clear IH2,
    --refine @sigma (a = a') _,
    refine Σ(p : a = a'), _,
    intro p, induction p, exact Π(b : B a), IH b (f' b)
  end

  theorem is_hprop_lt2 (v w : W a, B a) : is_hprop (lt2 v w) :=
  begin
    revert w,
    induction v with a f IH,
    intro w, induction w with a' f' IH2, clear IH2,
    unfold [lt2], apply is_trunc_sigma,
    -- it is false if A is not a set?
    repeat exact sorry
  end
  print nat.below
  print Wtype.below
    print prefix Wtype

  definition hprop_sigma {A : hprop} (B : A → hprop) : hprop :=
  trunctype.mk (Σa, B a) _

  -- definition lt3 (v w : W a, B a) : hprop.{max u v} :=
  -- begin
  --   revert w, induction v with a f IH, intro w, induction w with a' f' IH2, clear IH2,
  --   --refine @sigma (a = a') _,
  --   fapply trunctype.mk,
  --   { refine @hprop_sigma (trunctype.mk (∥a = a'∥) _) _, esimp,
  --     intro p, exact sorry},
  --   { exact sorry}
  -- end



  -- BUG IN DEFINITIONAL PACKAGE?
  -- definition lt2 : (W a, B a) → (W a, B a) → Type.{max u v}
  -- | lt2 (sup a f) (sup a' f') := Σ(p : a = a'), (Π(b : B a), lt2 (f b) (f' (p ▸ b)))

  -- theorem is_hprop_lt (v w : W a, B a) : is_hprop (v < w) :=
  -- begin
  --   revert w,
  --   induction v with a f IH,
  --   intro w, induction w with a' f' IH2, clear IH2,

  -- end




  end

  exit

  section
  parameters {A : Type} (B : A → Type) (R : A → A → Type)

  inductive Wsusp_rel {a : A} (Pf : B a → Type) : (Πb, Pf b) → (Πb, Pf b) → Type :=
  | Rmk : Π{a' : A} (r : R a a') (l : B a → (Πb, Pf b)) (r : B a' → (Πb, Pf b)),
          Wsusp_rel Pf _ _

  definition P (w : W a, B a) : Type :=
  begin
    induction w with a f Pf,
    exact @quotient (Πb, Pf b) _
  end

  definition Wsusp : Type := W_colim A B P _

  end

end Wtype


-- namespace Wsusp

--   section
--   parameters {A : Type} (B : A → Type) (R : A → A → Type)

--   inductive Wsusp_rel {a : A} (Pf : B a → Type) : (Πb, Pf b) → (Πb, Pf b) → Type :=
--   | Rmk : Π{a' : A} (r : R a a') (l : B a → (Πb, Pf b)) (r : B a' → (Πb, Pf b)),
--           Wsusp_rel Pf _ _

--   definition P (w : W a, B a) : Type :=
--   begin
--     induction w with a f Pf,
--     exact @quotient (Πb, Pf b) _
--   end

--   definition Wsusp : Type := W_colim A B P _

--   end

-- end Wsusp
